Polonator Image Processing Software
Church Lab, Harvard University
originally written by Greg Porreca, 01-28-08
current revision: 05-21-2008 GP


This document describes the image processing software for the G.007 Polonator DNA sequencer.

================================================================================


OVERVIEW

The purpose of the Polonator data processing pipeline is to convert bitmap images of fluorescent beads generated by the device's camera into DNA sequence (including basecall quality scores and graphical tetrahedral plots).   Conceptually, the task is divided into two parts: 1) data extraction from raw images, and 2) normalization and filtering of extracted data to generate basecalls.   Each 3-day run of the instrument generates approximately 7TB of image data (~3.5x10^6 2MB 1MPix images). 

To provide maximum process efficiency and limit computational requirements, the Polonator software has been designed to perform data extraction in realtime as the instrument runs â€“ images are created, processed, and discarded without ever being written to disk.  Should archiving of raw images be desired, the system can be run on a remote machine, such as a RAID array, with a compile-time flag set to turn image saving 'on'.  The pipeline should only be run from a machine with a RAID level that provides striping, since the write speed to a single disk is not sufficient to meet the pipeline's maximum throughput spec.  To allow the user to monitor run performance in realtime, the basecaller simultaneously generates quality control graphs and metrics.

 At the conclusion of the run, the instrument's internal processing node contains all extracted data necessary (approximately 200GB) to generate basecalls.   The basecaller is executed and produces a text file of reads, containing basecalls and their associated quality scores.

================================================================================


PROCESSOR QUICK-START GUIDE

To run the imaging processing pipeline, do the following:
1) Generate a new data directory on the processing hard disk; from the processor command line, execute:
	./setup_run.pl /path/to/run-data/and/name
	e.g.
	./setup_run.pl /mnt/data/run01232008a
2) Initialize the pipeline for the current run of data:
	cd /mnt/data/run01232008
	./initialize_processor.pl
	The source will be compiled, images processed, and 'working' files generated
3) Run brightfield imaging on the instrument:
	<INSERT COMMAND HERE>
	The images will automatically be transferred and processed in realtime
4) Start the pipeline for fluorescence image processing:
	./processor.pl
	This process will continue to execute for the entire instrument run, receiving and processing
	data as it arrives from the acquisition computer

To generate QC data after a cycle of imaging is complete, execute the following from the root of the run directory:
 For image alignment maps,
 ./disp_regQC.pl <cyclename>  WHERE cyclename is the name of the cycle just completed, e.g. AM1a

 For tetrahedra / quality info,
 ./disp_tetra-delta.pl <cyclename>  WHERE cyclename is the name of the cycle just completed, e.g. AM1a

Figures will be saved as TIF images in the QC directory.  

================================================================================


SETUP_RUN.PL
This script lives in the home directory of the user running the processing, e.g.
/home/processor/setup_run.pl

It relies on a tarball, called "current", living in directory "pipeline":
/home/processor/pipeline/current

We generally make "current" a symlink to the tarball holding the current release.  To generate such a tarball, in the directory structure of the most recent release (e.g. /mnt/data/newrun), we do:
tar -cvf /home/processor/pipeline/polonator_pipeline_01-23-2008 *.pl *.mtemplate src
We then upload this to speedy.med.harvard.edu so users can download it to update their pipeline

When the script is executed, it creates the directory specified, untars the current tarball into that directory, and then copies the tarball into the directory as "pipeline_archive.tar" for future reference.

================================================================================


INITIALIZE_PROCESSOR.PL
This script lives in the root directory of the data directory structure created by setup_run.pl.  Its purpose is to:
1) compile all source so the pipeline can be executed
2) start initialize_processor.c binary to receive and process brightfield images from acquisition computer
3) execute make_regfile.c binary to generate working data used by the registration algorithm during data extraction as the pipeline processes fluorescence images

Be sure to set $ACQUISITION_IP to the /etc/hosts hostname of the acquisition computer.  It is set by default to the configuration shipped from Danaher.

Initialize_processor.pl should only be executed once (successfully) in a given data directory.  Since its purpose is to prepare the pipeline living in its directory to receive fluorescent data, executing it multiple times is not necessary, and if done accidentally during a run, could clobber vital data.  The script contains logic to attempt to prevent unintended multi-execution, but the user should not attempt to do so in any case.

Initialize_processor.c generates two files used by the pipeline during fluorescence data extraction: the object table, and a 'summary', or 'info' file.  The object table contains a list of all object locations in all images.  It is separated into variable-length records; each contains information for all objects in a single image.  The record structure is shown below:  

FIELD		VALUE			SIZE		DESCRIPTION
start		-1			4 bytes		start of next block (1 block per image)
flowcell_id	{0..FCs_PER_RUN - 1}	4 bytes		the number of flowcells currently on the Polonator (usually 1 or 2)
array_id	{0..ARRAYS_PER_FC - 1}	4 bytes		the number if arrays the Polonator will image per flowcell (usually 18)
image_id	{0..IMGS_PER_ARRAY - 1}	4 bytes		the number of images per array the Polonator will acquire (usually 2514)
num_objects	{0..65535}		4 bytes		maximum number of objects per frame is largest allowable short unsigned int
beadpos_xcol	{0..NUM_XCOLS - 1}	2 bytes		X image position of centroid for current bead
beadpos_yrow	{0..NUM_YROWS - 1}	2 bytes		Y image position of centroid for current bead
.
.
.
end		0			2 bytes		end of record; not meaningful except to confirm in presence of -1 as next value
**names in caps refer to values specified at compile-time in file ProcessorParams.h; 4 byte values are "int", 2 byte values are "short unsigned int"

The corresponding info file contains one fixed-length record per image, with the following fields:
FIELD		VALUE			SIZE		DESCRIPTION
flowcell_id	{0..FCs_PER_RUN - 1}	2 bytes		the number of flowcells currently on the Polonator (usually 1 or 2)
array_id	{0..ARRAYS_PER_FC - 1}	2 bytes		the number if arrays the Polonator will image per flowcell (usually 18)
image_id	{0..IMGS_PER_ARRAY - 1}	2 bytes		the number of images per array the Polonator will acquire (usually 2514)
num_objects	{0..65535}		2 bytes		maximum number of objects per frame is largest allowable short unsigned int

This file is used, among other things, to parse the bead files during basecalling

Make_regfile.c generates two files, one of which is used by the registration algorithm to align fluorescence images to the object table.  The 'reg' file contains a subset of the X,Y centroid coordinates from the object table -- this is the list of points which are auto-correlated to find the optimal pixel offset for each image.  By performing the autocorrelation operation on a subset of the objects in the image, we are able to run the pipeline in realtime.  The number of objects used is specified as REG_PIXELS in ProcessorParams.h, and is generally 2000.  Objects are selected randomly, so the 'reglog' file stores the object ID for each point selected. 

================================================================================


PROCESSOR
While the Polonator is collecting fluorescence data, processor.c is running on the processing computer to extract 'bead' values from the images.  When processor.c starts, it loads the full reg file into memory.  As images stream into the pipeline by TCP from the acquisition computer, the pixels specified by the corresponding part of the regfile are summed over offsets in X from -SEARCH_XCOLS to +SEARCH_XCOLS and Y from -SEARCH_YROWS to +SEARCH_YROWS.  The sum of bead-pixels in the regfile will be maximal when the fluorescence image is in register with the object table (since 'beads' will generally have higher pixel values than background).  Once the best X,Y offset pair has been found, the record from the object table corresponding to the current image is read from disk.  These coordinates are translated by the X,Y registration offsets, and corresponding pixel values from the fluorescence image are extracted and written to disk.  Extracted bead values are written to 'bead' files in the /beads/ directory.  One file per set of images is generated.     



================================================================================
OUTPUT FILE CONTENTS

Several types of files are generated by the image processing pipeline:

A) beads/*.beads: one value per bead per color, short unsigned int; pixel value from raw image at the pixel location specified in the object table; THIS IS THE 'RAW' DATA THAT FORMS THE INPUT TO THE BASECALLER

B) beads/*.beadsums: one value per image per color, long long int; sum of all bead pixel values in the image; must be scaled by the number of beads in the image to be informative

C) beads/*.beadsums_full: one value per image per color, long long int; sum of 1000 pixels in the image (every 100th pixel of the first 100000 pixels)

D) output_data/*.tetracoords:
   One file per well for each run of the 'QC' software (filename is cyclename-QC-flowcell-well.tetracoords).  Text file w/ the following fields left to right (one row per bead, only includes data for every 100th image to keep file size reasonable):
       flowcell #
       well #
       image #
       bead #
       assignment (this is the basecall, [0123]==[ACGT]
       quality score ([0..1], lower numbers are better)
       raw bead values (4 numbers, straight from the 4 bead files)
       normalized bead values (4 numbers, calculated from the 4 raw bead values)
   This file is used to generate tetrahedron plots, but is also useful if one wishes to get at the 'raw' normalized data for select images. 

E) output_data/*.delta:
   One file per run of the 'QC' software (filename is cyclename-QC.delta).  Text file with the following fields left to right (one row per image, includes all data from all images):
       flowcell #
       well #
       image #
       delta values (one per basecall-identity [ACGT]); high values are good, low values are bad

F) output_data/*.basecalls: 
   One file per well per run of the basecaller; THIS FILE CONTAINS THE READS AND QUALITY SCORES -- IT IS THE 'OUTPUT' OF THE INSTRUMENT.  Text file with the following fields left to right (one row per bead, for all beads which passed the basecaller's quality thresholds):
       flowcell #
       well #
       image #
       bead #
       read (basecalls are [ACGT], a 'no basecall' is "."; basecalls are the identity of the bead-bound template strand, listed from its 5'->3')
       quality scores (one per basecall, [0..1000], low is good, high is bad)



       